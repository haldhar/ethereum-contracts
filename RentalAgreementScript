
Let’s create a short term rental agreement smart contract in Solidity, one of Ethereum’s high level languages. This is the kind of rental agreement that an apartment owner might use if someone was going to rent their apartment for a night or a week. 

Now this is really important. We’re going to create a contract that is between a specific apartment owner and a specific renter. It’s not a standing offer that you put on the blockchain and anyone can come and accept accept. Further, we’re going to assume that these two parties have some kind of pre-existing relationship and a way of communicating off-blockchain.

The reason that is important is this: the way our contract works is that our owner is going to issue this contract to the blockchain. Around the same time, they’re going to send an encrypted apartment entry code to the renter. They might use a service like encipher.it, for example, to do this. If the renter pays the rental fee before the rental date, they’re going to get the key or password to that encrypted entry code. The reason we can’t put both the encrypted entry code and the key together on the blockchain should be obvious. The blockchain is transparent. Anyone could decrypt the entry code and run amok in the apartment.

So based on those assumptions and that sort of deal flow, let’s get started. I do my prototyping in Christian Reitweissner’s Solidity Compiler. That’s the URL there. It’s really amazing resource. It checks your syntax in real time. 

So the first thing that we’ll need to do is do our contract declaration. As I said, it’s a lot like declaring a class in object oriented programming. 

Next thing we need to do is declare some variables.
Let’s have declare an address variable for our apartment owner.
Let’s have declare another address variable for our apartment renter.
Let’s declare a string for the the password or the key to that encrypted door code that the apartment entry owner is going to send via some other communication method.
Now let’s declare a couple booleans that we’ll use to keep track of whether certain events in our deal flow have occurred or not.
Let’s set a boolean that tracks whether the fee for the rental period has been paid. 
Let’s set another that tracks whether the apartment owner has set or sent the key or password to the contract.
Lastly, let’s set one that tracks whether the renter has retrieved that key.
Final, let’s set two integer variables. And the only reason I am using the unsigned integer typed instead of a flexible type like var is that I’ve been having a little trouble with var inside the Solidity compiler sometimes. But generally var is preferable here.
So let’s have one integer that tracks our rental fee.
And let’s have another integer that tracks our rental date. Notice that time on Ethereum is UNIX time in seconds. 

Next let’s set a constructor. So constructor is a function called just once, during the instantiation of the contract and we are going to use it to set some values for our variables at that point.
We’re going to pass a couple things into the constructor: our renter address, our rental fee, and our rental date. The one thing we don’t have to pass in is the owner’s address because we can just use message dot sender for that. So let’s assign message dot sender to our owner variable and then and then assign those other parameters we pass in to the appropriate variables. 

And that is our constructor.

Next let’s have a function that allows our renter to pay the rental value into the contract, by calling the function and adding ether to that transaction. Anything they send in will stay with the contract. A lot of folks call this the escrow quality of a smart contract. 
There’s no parameters. But let’s set up some conditions: first we want to check that the sender is indeed the renter. We don’t want other people calling the function. Next let’s check that it is not past the rental date. Last let’s make sure that the value they are sending in is not less than the rental fee. 
If all of those conditions are satisfied, let’s set our rent paid boolean to true. 
If any condition is not satisfied, let’s reroute the amount of ether that was sent in with the transaction right back to the sender. We don’t want it to stay in the contract.

Next let’s have a function that allows our owner to send in the key and get paid.  Naturally, he will want to make sure that renter has paid that value into the contract before he goes and issues the key to the contract.
This time we’ll allow a parameter to be passed in and that will of course be the string itself. 
Again, let’s have some conditions. Let’s check to make sure the sender is the owner. Don’t want anyone else setting the key. Let’s make sure the rental date has not passed and let’s also make sure that the rent has already been paid, just to reinforce our deal flow here. 
If all of that is true, let’s set the key that is end in as a parameter with the function call as our key string variable. Let’s toggle key sent to true. And lastly, let’s pay our owner the fee that the owner the fee that the renter sent in.

Now that the key has been set, the third function will be one that lets the renter retrieve that key. now the toppling on this function is a little different because we are actually going to return the key — the string — to the sender. So we need do state, in a parameter, that this function is going to return a string. Next let’s set some conditionals that are pretty similar to the ones we set above, making sure of the sender and making sure the rental date hasn’t passed and that both the key is set and the rent is paid. If all of that is true, we will toggle key received to true. And we will send that key string back to the person call the function, the renter.

Now let’s say that our renter is well-behaved and pays his rent but that our owner never sends his key before the rental date passes. If that happens, we want to return the rental fee to the the renter. Our penultimate function is one that lets us do that. Let’s call it refund. We’re going to check the sender, check that the rental date IS PASSED this time, check that the rent was paid, and check that the key WAS NOT sent. If all of that is true, we will send the balance of the contract back to the caller of the function.

Lastly, we want to the option to undo the contract if something unforeseen happens. Let’s say the apartment burns down or the owner’s state outlaws this type of rental. we’ll call this kill. We’ll let the owner call this one. Though if I had more time, I’d design a system that lets each party approve the killing of the contract. And then we’ll put atheneum’s global suicide function in there. That takes one parameter and it’s the address to send the contract balance too and we’ll make that the owner for simplicity sake as well.

And there you have it, a rental agreement contract in Solidity. 


